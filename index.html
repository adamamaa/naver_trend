<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>네이버 트렌드 분석</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 기본 폰트 설정 (선택 사항) */
        body {
            font-family: 'Inter', sans-serif; /* Inter 폰트 또는 시스템 기본 폰트 사용 */
        }
        /* 로딩 스피너 스타일 */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto; /* 가운데 정렬 */
            display: none; /* 기본적으로 숨김 */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* 차트 컨테이너 기본 숨김 (JS로 제어) */
        #chartContainer {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100 p-6 md:p-10 font-['Inter']">

    <div class="max-w-4xl mx-auto bg-white p-8 rounded-lg shadow-md">
        <h1 class="text-2xl md:text-3xl font-bold text-center mb-6 text-blue-600">네이버 트렌드 분석 (백엔드 연동)</h1>

        <div class="mb-6">
            <label for="keywords" class="block text-sm font-medium text-gray-700 mb-2">분석할 키워드를 입력하세요 (쉼표로 구분):</label>
            <input type="text" id="keywords" name="keywords" class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="예: 인공지능, 빅데이터, 클라우드">
        </div>

        <div class="text-center mb-6">
            <button id="analyzeButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-md transition duration-150 ease-in-out">
                분석 시작
            </button>
        </div>

        <div id="loadingIndicator" class="loader mb-4"></div>

        <div id="results" class="mt-6 p-4 bg-gray-50 rounded-md border border-gray-200 min-h-[100px]">
            <h2 class="text-xl font-semibold mb-3 text-gray-800">분석 결과</h2>
            <p id="resultText" class="text-gray-600">분석할 키워드를 입력하고 '분석 시작' 버튼을 눌러주세요.</p>

            <div id="chartContainer" class="relative h-96 mt-4">
                <canvas id="trendChart"></canvas> </div>
        </div>

        <div id="errorMessage" class="mt-4 p-3 bg-red-100 text-red-700 rounded-md border border-red-300 text-sm" style="display: none;">
            오류 메시지가 여기에 표시됩니다.
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
        // DOM 요소 참조
        const keywordsInput = document.getElementById('keywords');
        const analyzeButton = document.getElementById('analyzeButton');
        const resultsDiv = document.getElementById('results');
        const resultText = document.getElementById('resultText');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const errorMessageDiv = document.getElementById('errorMessage');
        const chartContainer = document.getElementById('chartContainer');
        const trendChartCanvas = document.getElementById('trendChart');
        let trendChart = null; // Chart.js 인스턴스 저장 변수

        // 백엔드 API 엔드포인트 URL (Vercel Serverless Function 경로)
        const backendApiUrl = '/api/analyze-trends';

        // '분석 시작' 버튼 클릭 이벤트 리스너
        analyzeButton.addEventListener('click', async () => {
            const keywords = keywordsInput.value.trim();
            // 입력값 유효성 검사
            if (!keywords) {
                showError("분석할 키워드를 입력해주세요.");
                return;
            }

            // 쉼표로 구분된 키워드를 배열로 변환하고 빈 항목 제거
            const keywordList = keywords.split(',').map(k => k.trim()).filter(k => k);
            if (keywordList.length === 0) {
                showError("유효한 키워드를 입력해주세요.");
                return;
            }

            // 분석 시작 전 UI 초기화
            resultText.style.display = 'none'; // 기본 안내 텍스트 숨김
            chartContainer.style.display = 'none'; // 차트 컨테이너 숨김
            if (trendChart) {
                trendChart.destroy(); // 이전 차트 인스턴스 제거
            }
            errorMessageDiv.style.display = 'none'; // 오류 메시지 숨김
            loadingIndicator.style.display = 'block'; // 로딩 스피너 표시
            analyzeButton.disabled = true; // 분석 중 버튼 비활성화

            try {
                // 백엔드 API 호출 (POST 요청)
                const response = await fetch(backendApiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    // 키워드 목록을 JSON 형태로 요청 본문에 담아 전송
                    body: JSON.stringify({ keywords: keywordList })
                });

                // 백엔드 응답 데이터 파싱
                const responseData = await response.json();

                // 백엔드 응답 상태 코드 확인 (오류 처리)
                if (!response.ok) {
                    // 백엔드에서 보낸 오류 메시지가 있으면 사용, 없으면 기본 메시지
                    throw new Error(responseData.error || `서버 오류 발생: ${response.status}`);
                }

                // 백엔드로부터 받은 데이터를 Chart.js 형식으로 변환
                const chartData = convertNaverDataToChartData(responseData);

                // 변환된 데이터 유효성 검사 및 결과 표시
                if (!chartData || chartData.labels.length === 0) {
                     showError("분석 결과를 가져왔으나 표시할 데이터가 없습니다. 기간이나 키워드를 확인해주세요.");
                } else {
                    displayResults(chartData); // 차트 표시 함수 호출
                }

            } catch (error) {
                // 네트워크 오류 또는 백엔드/API 오류 처리
                console.error("분석 요청 중 오류 발생:", error);
                showError(`분석 요청 실패: ${error.message}`);
            } finally {
                // 분석 완료 후 UI 정리
                loadingIndicator.style.display = 'none'; // 로딩 스피너 숨김
                analyzeButton.disabled = false; // 버튼 활성화
            }
        });

        /**
         * 네이버 API 응답 데이터를 Chart.js 데이터 형식으로 변환하는 함수
         * @param {object} naverData - 백엔드로부터 받은 네이버 API 응답 데이터
         * @returns {object|null} Chart.js 데이터 객체 또는 null (오류/데이터 없음)
         */
        function convertNaverDataToChartData(naverData) {
             // 데이터 유효성 검사
             if (!naverData || !naverData.results || naverData.results.length === 0 || !naverData.results[0].data || naverData.results[0].data.length === 0) {
                console.warn("Received empty or invalid data from backend:", naverData);
                return null; // 유효하지 않으면 null 반환
            }

            try {
                // X축 레이블 (기간) 추출 (첫 번째 키워드 그룹 기준)
                const labels = naverData.results[0].data.map(d => d.period);
                // 각 키워드 그룹별 데이터셋 생성
                const datasets = naverData.results.map((resultGroup, index) => {
                    // 사용할 색상 배열
                    const colors = ['#3b82f6', '#ef4444', '#10b981', '#f97316', '#8b5cf6', '#ec4899', '#6b7280'];
                    return {
                        label: resultGroup.title, // 범례 레이블 (키워드)
                        data: resultGroup.data.map(d => d.ratio), // Y축 데이터 (상대적 관심도)
                        borderColor: colors[index % colors.length], // 선 색상
                        tension: 0.1, // 선의 곡률 (0이면 직선)
                        fill: false // 선 아래 영역 채우지 않음
                    };
                });
                // Chart.js가 요구하는 형식으로 반환
                return { labels: labels, datasets: datasets };
            } catch (e) {
                // 데이터 변환 중 오류 발생 시 처리
                console.error("Error converting backend data to chart format:", e, naverData);
                showError("백엔드 응답 데이터를 차트 형식으로 변환 중 오류가 발생했습니다.");
                return null; // 오류 시 null 반환
            }
        }

        /**
         * 차트를 화면에 표시하는 함수
         * @param {object} data - Chart.js 데이터 객체
         */
        function displayResults(data) {
            resultsDiv.style.display = 'block'; // 결과 영역 표시
            chartContainer.style.display = 'block'; // 차트 컨테이너 표시
            resultText.style.display = 'none'; // 기본 안내 텍스트 숨김

            // 캔버스 컨텍스트 가져오기
            const ctx = trendChartCanvas.getContext('2d');
            // 기존 차트 인스턴스가 있으면 파괴 (중복 생성 방지)
            if (trendChart) {
                trendChart.destroy();
            }
            // 새 차트 생성
            trendChart = new Chart(ctx, {
                type: 'line', // 라인 차트
                data: data,   // 차트 데이터
                options: {
                    responsive: true, // 반응형 활성화
                    maintainAspectRatio: false, // 중요: 컨테이너 크기에 맞추려면 false 유지
                    plugins: {
                        legend: { // 범례 설정
                            position: 'top', // 범례 위치 (위쪽)
                        },
                        title: { // 차트 제목 설정
                            display: true,
                            text: '키워드별 트렌드 변화'
                        }
                    },
                    scales: { // 축 설정
                        y: { // Y축
                            beginAtZero: true, // 0부터 시작
                            title: { // Y축 제목
                                display: true,
                                text: '상대적 관심도 (0-100)'
                            }
                        },
                        x: { // X축
                            title: { // X축 제목
                                display: true,
                                text: '기간'
                            }
                        }
                    }
                }
            });
        }

        /**
         * 오류 메시지를 화면에 표시하는 함수
         * @param {string} message - 표시할 오류 메시지
         */
        function showError(message) {
            errorMessageDiv.textContent = message; // 오류 메시지 설정
            errorMessageDiv.style.display = 'block'; // 오류 메시지 표시
            loadingIndicator.style.display = 'none'; // 로딩 스피너 숨김
            analyzeButton.disabled = false; // 버튼 활성화
            // 오류 발생 시 차트 컨테이너 숨김
            chartContainer.style.display = 'none';
            if (trendChart) {
                trendChart.destroy(); // 차트 인스턴스 제거
            }
            resultsDiv.style.display = 'block'; // 결과 영역은 보이게 유지 (오류 메시지 위함)
            resultText.textContent = ''; // 결과 영역 내 기본 텍스트 제거
            resultText.style.display = 'none';
        }
    </script>

</body>
</html>
