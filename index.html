<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>네이버 트렌드 분석 (백엔드 연동)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 기본 폰트 설정 (선택 사항) */
        body {
            font-family: 'Inter', sans-serif; /* Inter 폰트 또는 시스템 기본 폰트 사용 */
        }
        /* 로딩 스피너 스타일 */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto; /* 가운데 정렬 */
            display: none; /* 기본적으로 숨김 */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 p-6 md:p-10 font-['Inter']">

    <div class="max-w-4xl mx-auto bg-white p-8 rounded-lg shadow-md">
        <h1 class="text-2xl md:text-3xl font-bold text-center mb-6 text-blue-600">네이버 트렌드 분석 (백엔드 연동)</h1>

        <div class="mb-6">
            <label for="keywords" class="block text-sm font-medium text-gray-700 mb-2">분석할 키워드를 입력하세요 (쉼표로 구분):</label>
            <input type="text" id="keywords" name="keywords" class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="예: 인공지능, 빅데이터, 클라우드">
        </div>

        <div class="text-center mb-6">
            <button id="analyzeButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-md transition duration-150 ease-in-out">
                분석 시작
            </button>
        </div>

        <div id="loadingIndicator" class="loader mb-4"></div>

        <div id="results" class="mt-6 p-4 bg-gray-50 rounded-md border border-gray-200 min-h-[100px]">
            <h2 class="text-xl font-semibold mb-3 text-gray-800">분석 결과</h2>
            <p id="resultText" class="text-gray-600">분석할 키워드를 입력하고 '분석 시작' 버튼을 눌러주세요.</p>
            <canvas id="trendChart" class="mt-4" style="display: none;"></canvas>
        </div>

        <div id="errorMessage" class="mt-4 p-3 bg-red-100 text-red-700 rounded-md border border-red-300 text-sm" style="display: none;">
            오류 메시지가 여기에 표시됩니다.
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
        const keywordsInput = document.getElementById('keywords');
        const analyzeButton = document.getElementById('analyzeButton');
        const resultsDiv = document.getElementById('results');
        const resultText = document.getElementById('resultText');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const errorMessageDiv = document.getElementById('errorMessage');
        const trendChartCanvas = document.getElementById('trendChart');
        let trendChart = null; // 차트 인스턴스 저장 변수

        // 백엔드 API 엔드포인트 주소 (Vercel Serverless Function 경로)
        const backendApiUrl = '/api/analyze-trends'; // '/api/' 로 시작하는 상대 경로 사용

        analyzeButton.addEventListener('click', async () => { // async 추가
            const keywords = keywordsInput.value.trim();
            if (!keywords) {
                showError("분석할 키워드를 입력해주세요.");
                return;
            }

            const keywordList = keywords.split(',').map(k => k.trim()).filter(k => k); // 빈 문자열 제거
            if (keywordList.length === 0) {
                showError("유효한 키워드를 입력해주세요.");
                return;
            }

            // 이전 결과 및 오류 메시지 초기화
            resultText.style.display = 'none';
            if (trendChart) {
                trendChart.destroy();
                trendChartCanvas.style.display = 'none';
            }
            errorMessageDiv.style.display = 'none';
            loadingIndicator.style.display = 'block';
            analyzeButton.disabled = true;

            try {
                // 백엔드 API 호출 (Serverless Function 호출)
                const response = await fetch(backendApiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    // 키워드 목록을 JSON 형태로 백엔드에 전송
                    body: JSON.stringify({ keywords: keywordList })
                });

                // 백엔드 응답 상태 확인
                const responseData = await response.json(); // 응답 본문을 먼저 읽음

                if (!response.ok) {
                    // 백엔드에서 보낸 오류 메시지 사용
                    throw new Error(responseData.error || `서버 오류 발생: ${response.status}`);
                }

                // 백엔드로부터 받은 네이버 API 데이터를 Chart.js 형식으로 변환
                const chartData = convertNaverDataToChartData(responseData); // responseData 사용

                if (!chartData || chartData.labels.length === 0) {
                     showError("분석 결과를 가져왔으나 표시할 데이터가 없습니다. 기간이나 키워드를 확인해주세요.");
                } else {
                    displayResults(chartData); // 변환된 데이터로 차트 표시
                }

            } catch (error) {
                console.error("분석 요청 중 오류 발생:", error);
                showError(`분석 요청 실패: ${error.message}`);
            } finally {
                loadingIndicator.style.display = 'none';
                analyzeButton.disabled = false;
            }
        });

        // 네이버 API 응답(백엔드를 통해 받은)을 Chart.js 형식으로 변환하는 함수
        function convertNaverDataToChartData(naverData) {
             if (!naverData || !naverData.results || naverData.results.length === 0) {
                console.warn("Received empty or invalid data from backend:", naverData);
                return null;
            }

            try {
                const labels = naverData.results[0].data.map(d => d.period);
                const datasets = naverData.results.map((resultGroup, index) => {
                    const colors = ['#3b82f6', '#ef4444', '#10b981', '#f97316', '#8b5cf6', '#ec4899', '#6b7280'];
                    return {
                        label: resultGroup.title,
                        data: resultGroup.data.map(d => d.ratio),
                        borderColor: colors[index % colors.length],
                        tension: 0.1,
                        fill: false
                    };
                });

                return {
                    labels: labels,
                    datasets: datasets
                };
            } catch (e) {
                console.error("Error converting backend data to chart format:", e, naverData);
                showError("백엔드 응답 데이터를 차트 형식으로 변환 중 오류가 발생했습니다.");
                return null;
            }
        }

        // 결과 표시 함수 (차트 생성) - 이전과 동일
        function displayResults(data) {
            resultsDiv.style.display = 'block';
            trendChartCanvas.style.display = 'block';
            resultText.style.display = 'none';

            const ctx = trendChartCanvas.getContext('2d');
            if (trendChart) {
                trendChart.destroy();
            }
            trendChart = new Chart(ctx, {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: '키워드별 트렌드 변화' }
                    },
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: '상대적 관심도 (0-100)' } },
                        x: { title: { display: true, text: '기간' } }
                    }
                }
            });
        }

        // 오류 메시지 표시 함수 - 이전과 동일
        function showError(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
            loadingIndicator.style.display = 'none';
            analyzeButton.disabled = false;
            if (trendChart) {
                trendChart.destroy();
                trendChartCanvas.style.display = 'none';
            }
            resultsDiv.style.display = 'block';
            resultText.textContent = '';
            resultText.style.display = 'none';
        }
    </script>

</body>
</html>
